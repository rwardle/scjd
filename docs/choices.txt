1. Updated UI creation for new version of Swing EDT rule.
2. Used MVC pattern for UI with controller as mediator to facilitate testing.
3. Adding a new line after if,else,catch,finally statements to improve readability.
4. ConfigurationPresenter is not final to facilitate testing.
5. Using a static method to look up the correct application factory based on the application mode. If this needed to be dynamic then we could have stored application factory instances against applicatin mode tokens in a hashmap enabling to add extra ones dynamically.
6. Use of readFully method in Data class.
7. Decided to trim strings when reading in from DB file - works but for padding with spaces and padding with null-terminator (although not for null-terminated and then junk data in rest of field).
8 When writing out will pad with spaces for consistency with data file.
9. Using a single Data instance since no performance requirements and creating a new RAF for each client would be a bottleneck. Could have used a RAF pool but would be overkill.
10. Use of runtime exception in Data.java - instead of wrapping in RecordNotFoundException.
11. update method of Data.java - allowing empty string in data array but not nulls. Empty string so a record can be updated with an empty owner id to "unbook".
12. Didn't throw DuplicateKeyException from create method cos there is no primary key defined and didn't want to guess.
13. invalidRecNo check and incrementing of the recordCount after creating a record at the end of the file take place outside the sync blocks. There is potential for one thread doing a read/udpate/delete to check the rec no and get a recordnotfoundexception even though the record does exist because it has just been added in the create method but the record count has not been updated. Happy with this approach since the client doing the read/update/delete shouldn't be operating on that recordNumber if it is only just being created at the same time. Other option would be to move the validateRecNo and recordCount incrementation into the sync blocks but then that would mean that they would have to obtain the file lock to do a non-file operation which may return from the method straight away if the validation check fails.
14. When deleting the last record in the database the file length is not decreased - which means that the database will never get smaller in size. Shouldn't be an issue since deleted records can be overwritten as long as a load of records aren't added and then deleted straigth away.
15. Using thread ID to identify client locks. Because server is implemented using RMI and all lock/unlock operations take place on a single RMI call and hence a single thread of execution this is OK. RMI spec makes no guarantees with threads, see:
http://java.sun.com/j2se/1.5.0/docs/guide/rmi/spec/rmi-arch3.html
But this gives us 2 possibilites: a) concurrent requests are routed to separate threads and then locking with the thread ID will be OK given the lock/unlock on same thread contract. Or b) the requests will be handled concurrently on the same thread in which case the lock from the first request will have been released before the second lock request occurs and there will be no contention. Recognise that if a client was calling lock on one thread and operation/unlock on another then this implementation would not work but this is not possible in my app and I'm not coding fall all possibilities.
16. Use of thread ID - it is unique in lifetime of a thread (from javadoc) so even in a thread pool situation this is OK since if a thread is waiting or using the lock the thread is busy and is not in the pool for another reuqest to use.
17. Ensure recordCount is only incremented inside sync block on RAF. Also find loops over recordCount inside RAF sync block so this is OK. Reads to check that recNo is not beyond EOF are not synced on RAF - make recordCount volatile to ensure that latest recordCount is always seen?
18. read and find isRecordDeleted calls need to be inside RAF sync block because no logical record locking for these method calls whereas we know that a record cannot become deleted part way through an upate or delete method call because of logical record locking.
19. Mention that to convert this to a web application in future would be really easy -  just stick a web front-end as a client of the BrokerServicesImpl.
